[TOC]

# P14 

## 本章目标

MutexLock/MutexLockGuard 互斥锁
Condition                                   条件变量 
CountDownLatch                      倒计时门闩类

## Mutex 类图

### MuteLock

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/14.1.png" alt="image-20230101205702458" style="zoom:50%;" />

isLockedByThisThread() 是否当前线程拥有该锁

### MutexLockGuard

使用 RAII 封装

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/14.2.png" alt="image-20230101205828389" style="zoom:50%;" />

RAII ， 避免忘记解锁

MutexLockGuard 与 MutexLock 是关联关系

> 关联关系 ：二者之间没有存在整体与局部的关系
>
> 聚合关系： 二者之间存在整体与局部的关系
>
> 组合关系： 二者之间既存在整体与局部的关系，又负责对象的生存期



### mutex_test测试输出

single thread without lock 0.236612

single thread with lock 1.307962

1 thread(s) with lock 1.289032

2 thread(s) with lock 2.552723

3 thread(s) with lock 3.815750

4 thread(s) with lock 5.169259

5 thread(s) with lock 6.392334

6 thread(s) with lock 7.560353

7 thread(s) with lock 8.858318



## Condition 条件变量

### 条件变量使用规范

我对次知识点的印象：

互斥的，~~为了解决死锁问题？~~（error）

标准知识点：

条件变量：是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：

​		一个等待“条件变量的条件成立”而挂起

​		另一个线程使“条件成立” （给出条件成立信号）

为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。

```
1. 执行
   锁住 mutex
   while(condition)
   	wait
   解锁 mutex
2. 改变条件
   锁住 mutex
   更改条件
   signal 或 broadcast
   解锁
```

条件变量类型是 pthread_cond_t



### 类图

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/condition.png" alt="image-20230101221040627" style="zoom:50%;" />



### CountDownLatch类图

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/countdownMath.png" alt="image-20230101231523056" style="zoom:50%;" />

既可以用于所有子线程等待主线程发起 “起跑” 

也可以用于主线程等待子线程初始化完毕才开始工作



#### CountDownLatch_test1.cc

```c++
class Test {
public:
  Test(int numThreads): latch_(1), threads_(numThreads) {
    for (int i = 0; i < numThreads; ++i) { //创建出三个线程 {
      char name[32];
      snprintf(name, sizeof name, "work thread %d", i);
      threads_.push_back(new muduo::Thread(
            boost::bind(&Test::threadFunc, this), muduo::string(name)));
    }
    for_each(threads_.begin(), threads_.end(), boost::bind(&Thread::start, _1));}
  void run() {
    latch_.countDown();}
  void joinAll() {
    for_each(threads_.begin(), threads_.end(), boost::bind(&Thread::join, _1));}
private:
  void threadFunc() {
    latch_.wait();
    printf("tid=%d, %s started\n",CurrentThread::tid(),CurrentThread::name());
    printf("tid=%d, %s stopped\n", CurrentThread::tid(),CurrentThread::name());
  }
  CountDownLatch latch_;
  boost::ptr_vector<Thread> threads_;
};
int main() {
  printf("pid=%d, tid=%d\n", ::getpid(), CurrentThread::tid());
  Test t(3);
  sleep(3);
  printf("pid=%d, tid=%d %s running ...\n", ::getpid(), CurrentThread::tid(), CurrentThread::name());
  t.run(); // 3个线程执行顺序乱的
  t.joinAll();
  printf("number of created threads %d\n", Thread::numCreated());
}
```



# P15 两个队列实现

实际上是是生产者消费者问题

我对此知识点的记忆：多个生产者、消费者线程，共享的线程池缓冲区

------

标准的官方知识点：

生产者消费者问题，也称**有限缓冲问题**，是一个多进程同步的经典案例。

## 本章目标

BlockinngQueue<T>（无界缓冲区）

BoundedBlockingQueue<T>（有界缓冲区）

## 生产者消费者问题

假设队列有界，大小为 size

用两个信号量进行同步

​		semFull(Size) 初始值等于size，表示初始状态队列是空的，可以生产的产品个数为size，才会使队								 列变满

​		semEmplty(0) 表示初始状态队列是空的，可以生产的产品个数为0

生产者线程

```c++
// 队列已满，不需要生产者线程生产，则阻塞
p(semFull)   // 如果队列无界，则此行代码可以删除
//需要互斥保护，因为可能有多个线程同时访问
lock(mutex)
queue.push(x) 
unlock(mutex)
v(semEmpty)  表示有产品可以消费了，通知消费者线程
```

消费者线程

```c++
p(semEmpty)   没有产品可以消费，阻塞状态
queue.pop(x)
//消费产品，腾出空间，就可以通知生产者线程生产
p(semPull);    // 如果队列无界，则此行代码可以删除
```



## BlockingQueue<T>类图

muduo实现

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/BlockingQueue.png" alt="image-20230102095522604" style="zoom:50%;" />

mutex       互斥量

notEmpty 条件变量

##  BoundedBlockingQueue<T> 类图

队列有界，使用环形缓冲区来保存内存的拷贝

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/BoundedBlockingQueue.png" alt="image-20230104172017185" style="zoom:50%;" />

```c++
// BoundedBlockingQueue.h
  void put(const T& x)
  {
    MutexLockGuard lock(mutex_);
    while (queue_.full())
    {
      notFull_.wait();
    }
    assert(!queue_.full());
    queue_.push_back(x);
    notEmpty_.notify();
  }
```



# P16 线程池的实现

## 基本结构图

本质上也是生产者消费者问题

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/线程池.png" alt="线程池" style="zoom: 33%;" />



## muduo库实现

<img src="/home/erfenjiao/learn/大并发服务器架构/截图/P14/ThreadPool.png" alt="image-20230105192636681" style="zoom:50%;" />



